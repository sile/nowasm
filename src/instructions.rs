use crate::{reader::Reader, symbols::MemArg, vectors::Vectors, DecodeError};

#[derive(Debug, Clone, Copy)]
pub enum Instr {
    // Control Instructions
    Unreachable,
    Nop,
    // Block(BlockInstr),
    // Loop(LoopInstr),
    // If(IfInstr),
    // Br(LabelIdx),
    // BrIf(LabelIdx),
    // BrTable(BrTable),
    // Return,
    // Call(FuncIdx),
    // CallIndirect(TypeIdx),

    // Parametric Instructions
    Drop,
    Select,

    // Variable Instructions
    // LocalGet(LocalIdx),
    // LocalSet(LocalIdx),
    // LocalTee(LocalIdx),
    // GlobalGet(GlobalIdx),
    // GlobalSet(GlobalIdx),

    // Memory Instructions
    I32Load(MemArg),
    I64Load(MemArg),
    F32Load(MemArg),
    F64Load(MemArg),
    I32Load8S(MemArg),
    I32Load8U(MemArg),
    I32Load16S(MemArg),
    I32Load16U(MemArg),
    I64Load8S(MemArg),
    I64Load8U(MemArg),
    I64Load16S(MemArg),
    I64Load16U(MemArg),
    I64Load32S(MemArg),
    I64Load32U(MemArg),
    I32Store(MemArg),
    I64Store(MemArg),
    F32Store(MemArg),
    F64Store(MemArg),
    I32Store8(MemArg),
    I32Store16(MemArg),
    I64Store8(MemArg),
    I64Store16(MemArg),
    I64Store32(MemArg),
    MemorySize,
    MemoryGrow,

    // Numeric Instructions
    I32Const(i32),
    I64Const(i64),
    F32Const(f32),
    F64Const(f64),
    I32Eqz,
    I32Eq,
    I32Ne,
    I32LtS,
    I32LtU,
    I32GtS,
    I32GtU,
    I32LeS,
    I32LeU,
    I32GeS,
    I32GeU,
    I64Eqz,
    I64Eq,
    I64Ne,
    I64LtS,
    I64LtU,
    I64GtS,
    I64GtU,
    I64LeS,
    I64LeU,
    I64GeS,
    I64GeU,
    F32Eq,
    F32Ne,
    F32Lt,
    F32Gt,
    F32Le,
    F32Ge,
    F64Eq,
    F64Ne,
    F64Lt,
    F64Gt,
    F64Le,
    F64Ge,
    I32Clz,
    I32Ctz,
    I32Popcnt,
    I32Add,
    I32Sub,
    I32Mul,
    I32DivS,
    I32DivU,
    I32RemS,
    I32RemU,
    I32And,
    I32Or,
    I32Xor,
    I32Shl,
    I32ShrS,
    I32ShrU,
    I32Rotl,
    I32Rotr,
    I64Clz,
    I64Ctz,
    I64Popcnt,
    I64Add,
    I64Sub,
    I64Mul,
    I64DivS,
    I64DivU,
    I64RemS,
    I64RemU,
    I64And,
    I64Or,
    I64Xor,
    I64Shl,
    I64ShrS,
    I64ShrU,
    I64Rotl,
    I64Rotr,
    F32Abs,
    F32Neg,
    F32Ceil,
    F32Floor,
    F32Trunc,
    F32Nearest,
    F32Sqrt,
    F32Add,
    F32Sub,
    F32Mul,
    F32Div,
    F32Min,
    F32Max,
    F32Copysign,
    F64Abs,
    F64Neg,
    F64Ceil,
    F64Floor,
    F64Trunc,
    F64Nearest,
    F64Sqrt,
    F64Add,
    F64Sub,
    F64Mul,
    F64Div,
    F64Min,
    F64Max,
    F64Copysign,
    I32WrapI64,
    I32TruncF32S,
    I32TruncF32U,
    I32TruncF64S,
    I32TruncF64U,
    I64ExtendI32S,
    I64ExtendI32U,
    I64TruncF32S,
    I64TruncF32U,
    I64TruncF64S,
    I64TruncF64U,
    F32ConvertI32S,
    F32ConvertI32U,
    F32ConvertI64S,
    F32ConvertI64U,
    F32DemoteF64,
    F64ConvertI32S,
    F64ConvertI32U,
    F64ConvertI64S,
    F64ConvertI64U,
    F64PromoteF32,
    I32ReinterpretF32,
    I64ReinterpretF64,
    F32ReinterpretI32,
    F64ReinterpretI64,
}

impl Instr {
    pub fn decode(reader: &mut Reader, vectors: &mut impl Vectors) -> Result<Self, DecodeError> {
        let opcode = reader.read_u8()?;
        match opcode {
            // // Control Instructions
            // 0x00 => Ok(Some(Instr::Unreachable)),
            // 0x01 => Ok(Some(Instr::Nop)),
            // 0x02 => Ok(Some(Instr::Block(BlockInstr::new(self)?))),
            // 0x03 => Ok(Some(Instr::Loop(LoopInstr::new(self)?))),
            // 0x04 => Ok(Some(Instr::If(IfInstr::new(self)?))),
            // 0x0b => Ok(None),
            // 0x0c => Ok(Some(Instr::Br(LabelIdx(self.read_u32()?)))),
            // 0x0d => Ok(Some(Instr::BrIf(LabelIdx(self.read_u32()?)))),
            // 0x0e => Ok(Some(Instr::BrTable(BrTable::new(self)?))),
            // 0x0f => Ok(Some(Instr::Return)),
            // 0x10 => Ok(Some(Instr::Call(FuncIdx(self.read_u32()?)))),
            // 0x11 => {
            //     let idx = self.read_u32()?;
            //     if self.read_u8()? != 0 {
            //         return Err(DecodeError::MalformedData); //TODO
            //     }
            //     Ok(Some(Instr::CallIndirect(TypeIdx(idx))))
            // }
            // // Parametric Instructions
            // 0x1a => Ok(Some(Instr::Drop)),
            // 0x1b => Ok(Some(Instr::Select)),

            // // Variable Instructions
            // 0x20 => Ok(Some(Instr::LocalGet(LocalIdx(self.read_u32()?)))),
            // 0x21 => Ok(Some(Instr::LocalSet(LocalIdx(self.read_u32()?)))),
            // 0x22 => Ok(Some(Instr::LocalTee(LocalIdx(self.read_u32()?)))),
            // 0x23 => Ok(Some(Instr::GlobalGet(GlobalIdx(self.read_u32()?)))),
            // 0x24 => Ok(Some(Instr::GlobalSet(GlobalIdx(self.read_u32()?)))),

            // // Memory Instructions
            0x28 => Ok(Instr::I32Load(MemArg::decode(reader)?)),
            0x29 => Ok(Instr::I64Load(MemArg::decode(reader)?)),
            0x2a => Ok(Instr::F32Load(MemArg::decode(reader)?)),
            0x2b => Ok(Instr::F64Load(MemArg::decode(reader)?)),
            0x2c => Ok(Instr::I32Load8S(MemArg::decode(reader)?)),
            0x2d => Ok(Instr::I32Load8U(MemArg::decode(reader)?)),
            0x2e => Ok(Instr::I32Load16S(MemArg::decode(reader)?)),
            0x2f => Ok(Instr::I32Load16U(MemArg::decode(reader)?)),
            0x30 => Ok(Instr::I64Load8S(MemArg::decode(reader)?)),
            0x31 => Ok(Instr::I64Load8U(MemArg::decode(reader)?)),
            0x32 => Ok(Instr::I64Load16S(MemArg::decode(reader)?)),
            0x33 => Ok(Instr::I64Load16U(MemArg::decode(reader)?)),
            0x34 => Ok(Instr::I64Load32S(MemArg::decode(reader)?)),
            0x35 => Ok(Instr::I64Load32U(MemArg::decode(reader)?)),
            0x36 => Ok(Instr::I32Store(MemArg::decode(reader)?)),
            0x37 => Ok(Instr::I64Store(MemArg::decode(reader)?)),
            0x38 => Ok(Instr::F32Store(MemArg::decode(reader)?)),
            0x39 => Ok(Instr::F64Store(MemArg::decode(reader)?)),
            0x3a => Ok(Instr::I32Store8(MemArg::decode(reader)?)),
            0x3b => Ok(Instr::I32Store16(MemArg::decode(reader)?)),
            0x3c => Ok(Instr::I64Store8(MemArg::decode(reader)?)),
            0x3d => Ok(Instr::I64Store16(MemArg::decode(reader)?)),
            0x3e => Ok(Instr::I64Store32(MemArg::decode(reader)?)),
            0x3f => {
                let value = reader.read_u8()?;
                if value != 0 {
                    return Err(DecodeError::InvalidMemorySizeMemoryIndex { value });
                }
                Ok(Instr::MemorySize)
            }
            0x40 => {
                let value = reader.read_u8()?;
                if value != 0 {
                    return Err(DecodeError::InvalidMemoryGrowMemoryIndex { value });
                }
                Ok(Instr::MemoryGrow)
            }

            // // Numeric Instructions
            0x41 => Ok(Instr::I32Const(reader.read_i32()?)),
            0x42 => Ok(Instr::I64Const(reader.read_i64()?)),
            0x43 => Ok(Instr::F32Const(reader.read_f32()?)),
            0x44 => Ok(Instr::F64Const(reader.read_f64()?)),
            0x45 => Ok(Instr::I32Eqz),
            0x46 => Ok(Instr::I32Eq),
            0x47 => Ok(Instr::I32Ne),
            0x48 => Ok(Instr::I32LtS),
            0x49 => Ok(Instr::I32LtU),
            0x4A => Ok(Instr::I32GtS),
            0x4B => Ok(Instr::I32GtU),
            0x4C => Ok(Instr::I32LeS),
            0x4D => Ok(Instr::I32LeU),
            0x4E => Ok(Instr::I32GeS),
            0x4F => Ok(Instr::I32GeU),
            0x50 => Ok(Instr::I64Eqz),
            0x51 => Ok(Instr::I64Eq),
            0x52 => Ok(Instr::I64Ne),
            0x53 => Ok(Instr::I64LtS),
            0x54 => Ok(Instr::I64LtU),
            0x55 => Ok(Instr::I64GtS),
            0x56 => Ok(Instr::I64GtU),
            0x57 => Ok(Instr::I64LeS),
            0x58 => Ok(Instr::I64LeU),
            0x59 => Ok(Instr::I64GeS),
            0x5A => Ok(Instr::I64GeU),
            0x5B => Ok(Instr::F32Eq),
            0x5C => Ok(Instr::F32Ne),
            0x5D => Ok(Instr::F32Lt),
            0x5E => Ok(Instr::F32Gt),
            0x5F => Ok(Instr::F32Le),
            0x60 => Ok(Instr::F32Ge),
            0x61 => Ok(Instr::F64Eq),
            0x62 => Ok(Instr::F64Ne),
            0x63 => Ok(Instr::F64Lt),
            0x64 => Ok(Instr::F64Gt),
            0x65 => Ok(Instr::F64Le),
            0x66 => Ok(Instr::F64Ge),
            0x67 => Ok(Instr::I32Clz),
            0x68 => Ok(Instr::I32Ctz),
            0x69 => Ok(Instr::I32Popcnt),
            0x6A => Ok(Instr::I32Add),
            0x6B => Ok(Instr::I32Sub),
            0x6C => Ok(Instr::I32Mul),
            0x6D => Ok(Instr::I32DivS),
            0x6E => Ok(Instr::I32DivU),
            0x6F => Ok(Instr::I32RemS),
            0x70 => Ok(Instr::I32RemU),
            0x71 => Ok(Instr::I32And),
            0x72 => Ok(Instr::I32Or),
            0x73 => Ok(Instr::I32Xor),
            0x74 => Ok(Instr::I32Shl),
            0x75 => Ok(Instr::I32ShrS),
            0x76 => Ok(Instr::I32ShrU),
            0x77 => Ok(Instr::I32Rotl),
            0x78 => Ok(Instr::I32Rotr),
            0x79 => Ok(Instr::I64Clz),
            0x7A => Ok(Instr::I64Ctz),
            0x7B => Ok(Instr::I64Popcnt),
            0x7C => Ok(Instr::I64Add),
            0x7D => Ok(Instr::I64Sub),
            0x7E => Ok(Instr::I64Mul),
            0x7F => Ok(Instr::I64DivS),
            0x80 => Ok(Instr::I64DivU),
            0x81 => Ok(Instr::I64RemS),
            0x82 => Ok(Instr::I64RemU),
            0x83 => Ok(Instr::I64And),
            0x84 => Ok(Instr::I64Or),
            0x85 => Ok(Instr::I64Xor),
            0x86 => Ok(Instr::I64Shl),
            0x87 => Ok(Instr::I64ShrS),
            0x88 => Ok(Instr::I64ShrU),
            0x89 => Ok(Instr::I64Rotl),
            0x8A => Ok(Instr::I64Rotr),
            0x8B => Ok(Instr::F32Abs),
            0x8C => Ok(Instr::F32Neg),
            0x8D => Ok(Instr::F32Ceil),
            0x8E => Ok(Instr::F32Floor),
            0x8F => Ok(Instr::F32Trunc),
            0x90 => Ok(Instr::F32Nearest),
            0x91 => Ok(Instr::F32Sqrt),
            0x92 => Ok(Instr::F32Add),
            0x93 => Ok(Instr::F32Sub),
            0x94 => Ok(Instr::F32Mul),
            0x95 => Ok(Instr::F32Div),
            0x96 => Ok(Instr::F32Min),
            0x97 => Ok(Instr::F32Max),
            0x98 => Ok(Instr::F32Copysign),
            0x99 => Ok(Instr::F64Abs),
            0x9A => Ok(Instr::F64Neg),
            0x9B => Ok(Instr::F64Ceil),
            0x9C => Ok(Instr::F64Floor),
            0x9D => Ok(Instr::F64Trunc),
            0x9E => Ok(Instr::F64Nearest),
            0x9F => Ok(Instr::F64Sqrt),
            0xA0 => Ok(Instr::F64Add),
            0xA1 => Ok(Instr::F64Sub),
            0xA2 => Ok(Instr::F64Mul),
            0xA3 => Ok(Instr::F64Div),
            0xA4 => Ok(Instr::F64Min),
            0xA5 => Ok(Instr::F64Max),
            0xA6 => Ok(Instr::F64Copysign),
            0xA7 => Ok(Instr::I32WrapI64),
            0xA8 => Ok(Instr::I32TruncF32S),
            0xA9 => Ok(Instr::I32TruncF32U),
            0xAA => Ok(Instr::I32TruncF64S),
            0xAB => Ok(Instr::I32TruncF64U),
            0xAC => Ok(Instr::I64ExtendI32S),
            0xAD => Ok(Instr::I64ExtendI32U),
            0xAE => Ok(Instr::I64TruncF32S),
            0xAF => Ok(Instr::I64TruncF32U),
            0xB0 => Ok(Instr::I64TruncF64S),
            0xB1 => Ok(Instr::I64TruncF64U),
            0xB2 => Ok(Instr::F32ConvertI32S),
            0xB3 => Ok(Instr::F32ConvertI32U),
            0xB4 => Ok(Instr::F32ConvertI64S),
            0xB5 => Ok(Instr::F32ConvertI64U),
            0xB6 => Ok(Instr::F32DemoteF64),
            0xB7 => Ok(Instr::F64ConvertI32S),
            0xB8 => Ok(Instr::F64ConvertI32U),
            0xB9 => Ok(Instr::F64ConvertI64S),
            0xBA => Ok(Instr::F64ConvertI64U),
            0xBB => Ok(Instr::F64PromoteF32),
            0xBC => Ok(Instr::I32ReinterpretF32),
            0xBD => Ok(Instr::I64ReinterpretF64),
            0xBE => Ok(Instr::F32ReinterpretI32),
            0xBF => Ok(Instr::F64ReinterpretI64),
            _ => Err(DecodeError::InvalidOpcode { value: opcode }),
        }
    }
}
